Learn JPA & Hibernate
						JPA is huge! It covers nearly every aspect of communication between relational databases and the Java application and is deeply integrated into all major frameworks.
			
			If you're using IntelliJ, JPA Buddy is super helpful. The plugin gently guides you through the subtleties of the most popular JPA implementations, visually reminds you of JPA features, generates code that follows best practices, and integrates intelligent inspections to improve your existing persistence code.
			
			More concretely, it provides powerful tooling to generate Spring Data JPA repositories and methods, Flyway Versioned Migrations, Liquibase Differential Changelogs, DDL and SQL statements, DTO objects, and MapStruct interfaces.
			
			Oh, and it actually generates JPA entities from an existing database and gradually update the data model as the database evolves! Yeah.
			
			>> Become a lot more productive with JPA Buddy
			
		Object-Relational Mapping (ORM) is the process of converting Java objects to database tables. In other words, this allows us to interact with a relational database without any SQL. The Java Persistence API (JPA) is a specification that defines how to persist data in Java applications. 
		The primary focus of JPA is the ORM layer.

 
				
		Hibernate is one of the most popular Java ORM frameworks in use today. Its first release was almost twenty years ago, and still has excellent community support and regular releases. Additionally, Hibernate is a standard implementation of the JPA specification, with a few additional features that are specific to Hibernate. 
				Let's take a look at some core features of JPA and Hibernate.
				
				TOPICS:
				
										
						series creational patterns - icon
						Defining Entities
						Defining JPA Entities
						Hibernate Entity Lifecycle
						JPA Entity Lifecycle Events
						Default Column Values in JPA
						JPA @Basic Annotation
						Mapping Entity Class Names to SQL Table Names with JPA
						Difference Between @Size, @Length, and @Column(length=value)
						JPA Entity Equality
						JPA @Embedded And @Embeddable
						JPA Attribute Converters
						Hibernate @NotNull vs @Column(nullable = false)
						Defining Unique Constraints in JPA
						JPA Entities and the Serializable Interface
						series structure patterns - icon
						Entity Relationships
						One-to-One Relationship in JPA
						Many-To-Many Relationship in JPA
						@JoinColumn Annotation Explained
						Difference Between @JoinColumn and mappedBy
						Mapping a Single Entity to Multiple Tables in JPA
						Overview of JPA/Hibernate Cascade Types
						Hibernate @WhereJoinTable Annotation
						Hibernate Inheritance Mapping
						Hibernate One to Many Annotation Tutorial
						series behavior patterns - icon
						Identifiers
						An Overview of Identifiers in Hibernate/JPA
						Composite Primary Keys in JPA
						When Does JPA Set the Primary Key
						java nio - icon
						Read Operations
						Types of JPA Queries
						JPA Query Parameters Usage
						Constructing a JPA Query Between Unrelated Entities
						Working with Lazy Element Collections in JPA
						JPA Join Types
						FetchMode in Hibernate
						Hibernate Named Query
						string primitive - icon
						Query Criteria
						Combining JPA And/Or Criteria Predicates
						Criteria API – An Example of IN Expressions
						JPA Criteria Queries
						series other patterns - icon
						Pagination and Sorting
						Sorting with JPA
						JPA Pagination
						Hibernate Pagination
						JPA Criteria Queries
						String Tools - icon
						Query Results
						A Guide to SqlResultSetMapping
						Customizing the Result of JPA Queries with Aggregation Functions
						java io conv - icon
						Write Operations
						INSERT Statement in JPA
						Batch Insert/Update with Hibernate/JPA
						Deleting Objects with Hibernate
						Hibernate: save, persist, update, merge, saveOrUpdate
						
1.Defining JPA Entities

			
							JPA is huge! It covers nearly every aspect of communication between relational databases and the Java application and is deeply integrated into all major frameworks.
			
			If you're using IntelliJ, JPA Buddy is super helpful. The plugin gently guides you through the subtleties of the most popular JPA implementations, visually reminds you of JPA features, generates code that follows best practices, and integrates intelligent inspections to improve your existing persistence code.
			
			More concretely, it provides powerful tooling to generate Spring Data JPA repositories and methods, Flyway Versioned Migrations, Liquibase Differential Changelogs, DDL and SQL statements, DTO objects, and MapStruct interfaces.
			
			Oh, and it actually generates JPA entities from an existing database and gradually update the data model as the database evolves! Yeah.
			
			
			1. Introduction
							In this tutorial, we'll learn about the basics of entities, along with various annotations that define and customize an entity in JPA.
							
							2. Entity
							Entities in JPA are nothing but POJOs representing data that can be persisted to the database. An entity represents a table stored in a database. Every instance of an entity represents a row in the table.
							
							2.1. The Entity Annotation
							Let's say we have a POJO called Student, which represents the data of a student, and we would like to store it in the database:
							
							public class Student {
							    
							    // fields, getters and setters
							    
							}
							Copy
							In order to do this, we should define an entity so that JPA is aware of it.
							
							So let's define it by making use of the @Entity annotation. We must specify this annotation at the class level. We must also ensure that the entity has a no-arg constructor and a primary key: 
							
							
							freestar
							@Entity
							public class Student {
							    
							    // fields, getters and setters
							    
							}
							Copy
							The entity name defaults to the name of the class. We can change its name using the name element:
							
							@Entity(name="student")
							public class Student {
							    
							    // fields, getters and setters
							    
							}
							Copy
							Because various JPA implementations will try subclassing our entity in order to provide their functionality, entity classes must not be declared final.
							
							2.2. The Id Annotation
							Each JPA entity must have a primary key that uniquely identifies it. The @Id annotation defines the primary key. We can generate the identifiers in different ways, which are specified by the @GeneratedValue annotation.
							
							We can choose from four id generation strategies with the strategy element. The value can be AUTO, TABLE, SEQUENCE, or IDENTITY:
							
							@Entity
							public class Student {
							    @Id
							    @GeneratedValue(strategy=GenerationType.AUTO)
							    private Long id;
							    
							    private String name;
							    
							    // getters and setters
							}
							Copy
							If we specify GenerationType.AUTO, the JPA provider will use any strategy it wants to generate the identifiers.
							
							If we annotate the entity's fields, the JPA provider will use these fields to get and set the entity's state. In addition to Field Access, we can also do Property Access or Mixed Access, which enables us to use both Field and Property access in the same entity.
							
							2.3. The Table Annotation
							In most cases, the name of the table in the database and the name of the entity won't be the same.
							
							In these cases, we can specify the table name using the @Table annotation:
							
							@Entity
							@Table(name="STUDENT")
							public class Student {
							    
							    // fields, getters and setters
							    
							}
							Copy
							We can also mention the schema using the schema element:
							
							@Entity
							@Table(name="STUDENT", schema="SCHOOL")
							public class Student {
							    
							    // fields, getters and setters
							    
							}
							Copy
							Schema name helps to distinguish one set of tables from another.
							
							If we don't use the @Table annotation, the name of the table will be the name of the entity.
							
							2.4. The Column Annotation
							Just like the @Table annotation, we can use the @Column annotation to mention the details of a column in the table.
							
							The @Column annotation has many elements such as name, length, nullable, and unique:
							
							@Entity
							@Table(name="STUDENT")
							public class Student {
							    @Id
							    @GeneratedValue(strategy=GenerationType.AUTO)
							    private Long id;
							    
							    @Column(name="STUDENT_NAME", length=50, nullable=false, unique=false)
							    private String name;
							    
							    // other fields, getters and setters
							}
							Copy
							The name element specifies the name of the column in the table. The length element specifies its length. The nullable element specifies whether the column is nullable or not, and the unique element specifies whether the column is unique.
							
							If we don't specify this annotation, the name of the column in the table will be the name of the field.
							
							2.5. The Transient Annotation
							Sometimes, we may want to make a field non-persistent. We can use the @Transient annotation to do so. It specifies that the field won't be persisted.
							
							For instance, we can calculate the age of a student from the date of birth.
							
							So let's annotate the field age with the @Transient annotation:
							
							@Entity
							@Table(name="STUDENT")
							public class Student {
							    @Id
							    @GeneratedValue(strategy=GenerationType.AUTO)
							    private Long id;
							    
							    @Column(name="STUDENT_NAME", length=50, nullable=false)
							    private String name;
							    
							    @Transient
							    private Integer age;
							    
							    // other fields, getters and setters
							}
							Copy
							As a result, the field age won't be persisted to the table.
							
							2.6. The Temporal Annotation
							In some cases, we may have to save temporal values in our table.
							
							For this, we have the @Temporal annotation:
							
							@Entity
							@Table(name="STUDENT")
							public class Student {
							    @Id
							    @GeneratedValue(strategy=GenerationType.AUTO)
							    private Long id;
							    
							    @Column(name="STUDENT_NAME", length=50, nullable=false, unique=false)
							    private String name;
							    
							    @Transient
							    private Integer age;
							    
							    @Temporal(TemporalType.DATE)
							    private Date birthDate;
							    
							    // other fields, getters and setters
							}
							Copy
							However, with JPA 2.2, we also have support for java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime, java.time.OffsetTime and java.time.OffsetDateTime.
							
							2.7. The Enumerated Annotation
							Sometimes, we may want to persist a Java enum type.
							
							We can use the @Enumerated annotation to specify whether the enum should be persisted by name or by ordinal (default):
							
							public enum Gender {
							    MALE, 
							    FEMALE
							}
							Copy
							@Entity
							@Table(name="STUDENT")
							public class Student {
							    @Id
							    @GeneratedValue(strategy=GenerationType.AUTO)
							    private Long id;
							    
							    @Column(name="STUDENT_NAME", length=50, nullable=false, unique=false)
							    private String name;
							    
							    @Transient
							    private Integer age;
							    
							    @Temporal(TemporalType.DATE)
							    private Date birthDate;
							    
							    @Enumerated(EnumType.STRING)
							    private Gender gender;
							    
							    // other fields, getters and setters
							}
							Copy
							Actually, we don't have to specify the @Enumerated annotation at all if we're going to persist the Gender by the enum‘s ordinal.
							
							However, to persist the Gender by enum name, we've configured the annotation with EnumType.STRING.

2.Hibernate Entity Lifecycle
				
							JPA is huge! It covers nearly every aspect of communication between relational databases and the Java application and is deeply integrated into all major frameworks.
				
				If you're using IntelliJ, JPA Buddy is super helpful. The plugin gently guides you through the subtleties of the most popular JPA implementations, visually reminds you of JPA features, generates code that follows best practices, and integrates intelligent inspections to improve your existing persistence code.
				
				More concretely, it provides powerful tooling to generate Spring Data JPA repositories and methods, Flyway Versioned Migrations, Liquibase Differential Changelogs, DDL and SQL statements, DTO objects, and MapStruct interfaces.
				
				Oh, and it actually generates JPA entities from an existing database and gradually update the data model as the database evolves! Yeah.		
											

											
										1. Overview
					Every Hibernate entity naturally has a lifecycle within the framework – it's either in a transient, managed, detached or deleted state.
					
					Understanding these states on both conceptual and technical level is essential to be able to use Hibernate properly.
					
					To learn about various Hibernate methods that deal with entities, have a look at one of our previous tutorials.
					
					2. Helper Methods
					Throughout this tutorial, we'll consistently use several helper methods:
					
					HibernateLifecycleUtil.getManagedEntities(session) – we'll use it to get all managed entities from a Session's internal store
					DirtyDataInspector.getDirtyEntities() – we're going to use this method to get a list of all entities that were marked as ‘dirty'
					HibernateLifecycleUtil.queryCount(query) – a convenient method to do count(*) query against the embedded database
					All of the above helper methods are statically imported for better readability. You can find their implementations in the GitHub project linked at the end of this article.
					
					
					freestar
					3. It's All About Persistence Context
					Before getting into the topic of entity lifecycle, first, we need to understand the persistence context.
					
					Simply put, the persistence context sits between client code and data store. It's a staging area where persistent data is converted to entities, ready to be read and altered by client code.
					
					Theoretically speaking, the persistence context is an implementation of the Unit of Work pattern. It keeps track of all loaded data, tracks changes of that data, and is responsible to eventually synchronize any changes back to the database at the end of the business transaction.
					
					JPA EntityManager and Hibernate's Session are an implementation of the persistence context concept. Throughout this article, we'll use Hibernate Session to represent persistence context.
					
					Hibernate entity lifecycle state explains how the entity is related to a persistence context, as we'll see next.
					
					
					freestar
					4. Managed Entity
					A managed entity is a representation of a database table row (although that row doesn't have to exist in the database yet).
					
					This is managed by the currently running Session, and every change made on it will be tracked and propagated to the database automatically.
					
					The Session either loads the entity from the database or re-attaches a detached entity. We'll discuss detached entities in section 5.
					
					Let's observe some code to get clarification.
					
					Our sample application defines one entity, the FootballPlayer class. At startup, we'll initialize the data store with some sample data:
					
					
					freestar
					+-------------------+-------+
					| Name              |  ID   |
					+-------------------+-------+
					| Cristiano Ronaldo | 1     |
					| Lionel Messi      | 2     |
					| Gianluigi Buffon  | 3     |
					+-------------------+-------+
					Copy
					Let's say we want to change the name of Buffon to start with – we want to put in his full name Gianluigi Buffon instead of Gigi Buffon.
					
					First, we need to start our unit of work by obtaining a Session:
					
					Session session = sessionFactory.openSession();
					Copy
					In a server environment, we may inject a Session to our code via a context-aware proxy. The principle remains the same: we need a Session to encapsulate the business transaction of our unit of work.
					
					Next, we'll instruct our Session to load the data from the persistent store:
					
					assertThat(getManagedEntities(session)).isEmpty();
					
					List<FootballPlayer> players = s.createQuery("from FootballPlayer").getResultList();
					
					assertThat(getManagedEntities(session)).size().isEqualTo(3);
					Copy
					When we first obtain a Session, its persistent context store is empty, as shown by our first assert statement.
					
					Next, we're executing a query which retrieves data from the database, creates entity representation of the data, and finally returns the entity for us to use.
					
					Internally, the Session keeps track of all entities it loads in the persistent context store. In our case, the Session's internal store will contain 3 entities after the query.
					
					Now let's change Gigi's name:
					
					
					freestar
					Transaction transaction = session.getTransaction();
					transaction.begin();
					
					FootballPlayer gigiBuffon = players.stream()
					  .filter(p -> p.getId() == 3)
					  .findFirst()
					  .get();
					
					gigiBuffon.setName("Gianluigi Buffon");
					transaction.commit();
					
					assertThat(getDirtyEntities()).size().isEqualTo(1);
					assertThat(getDirtyEntities().get(0).getName()).isEqualTo("Gianluigi Buffon");
					Copy
					4.1. How Does It Work?
					On call to transaction commit() or flush(), the Session will find any dirty entities from its tracking list and synchronize the state to the database.
					
					Notice that we didn't need to call any method to notify Session that we changed something in our entity – since it's a managed entity, all changes are propagated to the database automatically.
					
					A managed entity is always a persistent entity – it must have a database identifier, even though the database row representation is not yet created i.e. the INSERT statement is pending the end of the unit of work.
					
					See the chapter about transient entities below.
					
					5. Detached Entity
					A detached entity is just an ordinary entity POJO whose identity value corresponds to a database row. The difference from a managed entity is that it's not tracked anymore by any persistence context.
					
					An entity can become detached when the Session used to load it was closed, or when we call Session.evict(entity) or Session.clear().
					
					Let's see it in the code:
					
					FootballPlayer cr7 = session.get(FootballPlayer.class, 1L);
					
					assertThat(getManagedEntities(session)).size().isEqualTo(1);
					assertThat(getManagedEntities(session).get(0).getId()).isEqualTo(cr7.getId());
					
					session.evict(cr7);
					
					assertThat(getManagedEntities(session)).size().isEqualTo(0);
					Copy
					Our persistence context will not track the changes in detached entities:
					
					cr7.setName("CR7");
					transaction.commit();
					
					assertThat(getDirtyEntities()).isEmpty();
					Copy
					Session.merge(entity)/Session.update(entity) can (re)attach a session:
					
					FootballPlayer messi = session.get(FootballPlayer.class, 2L);
					
					session.evict(messi);
					messi.setName("Leo Messi");
					transaction.commit();
					
					assertThat(getDirtyEntities()).isEmpty();
					
					transaction = startTransaction(session);
					session.update(messi);
					transaction.commit();
					
					assertThat(getDirtyEntities()).size().isEqualTo(1);
					assertThat(getDirtyEntities().get(0).getName()).isEqualTo("Leo Messi");
					Copy
					For reference on both Session.merge() and Session.update() see here.
					
					5.1. The Identity Field Is All That Matters
					Let's have a look at the following logic:
					
					FootballPlayer gigi = new FootballPlayer();
					gigi.setId(3);
					gigi.setName("Gigi the Legend");
					session.update(gigi);
					Copy
					In the example above, we've instantiated an entity in the usual way via its constructor. We've populated the fields with values and we've set the identity to 3, which corresponds to the identity of persistent data that belongs to Gigi Buffon. Calling update() has exactly the same effect as if we've loaded the entity from another persistence context.
					
					In fact, Session doesn't distinguish where a re-attached entity originated from.
					
					It's quite a common scenario in web applications to construct detached entities from HTML form values.
					
					As far as Session is concerned, a detached entity is just a plain entity whose identity value corresponds to persistent data.
					
					Be aware that the example above just serves a demo purpose. and we need to know exactly what we're doing. Otherwise, we could end up with null values across our entity if we just set the value on the field we want to update, leaving the rest untouched (so, effectively null).
					
					
					freestar
					6. Transient Entity
					A transient entity is simply an entity object that has no representation in the persistent store and is not managed by any Session.
					
					A typical example of a transient entity would be instantiating a new entity via its constructor.
					
					To make a transient entity persistent, we need to call Session.save(entity) or Session.saveOrUpdate(entity):
					
					FootballPlayer neymar = new FootballPlayer();
					neymar.setName("Neymar");
					session.save(neymar);
					
					assertThat(getManagedEntities(session)).size().isEqualTo(1);
					assertThat(neymar.getId()).isNotNull();
					
					int count = queryCount("select count(*) from Football_Player where name='Neymar'");
					
					assertThat(count).isEqualTo(0);
					
					transaction.commit();
					count = queryCount("select count(*) from Football_Player where name='Neymar'");
					
					assertThat(count).isEqualTo(1);
					Copy
					As soon as we execute Session.save(entity), the entity is assigned an identity value and becomes managed by the Session. However, it might not yet be available in the database as the INSERT operation might be delayed until the end of the unit of work.
					
					7. Deleted Entity
					An entity is in a deleted (removed) state if Session.delete(entity) has been called, and the Session has marked the entity for deletion. The DELETE command itself might be issued at the end of the unit of work.
					
					Let's see it in the following code:
					
					session.delete(neymar);
					
					assertThat(getManagedEntities(session).get(0).getStatus()).isEqualTo(Status.DELETED);
					Copy
					However, notice that the entity stays in the persistent context store until the end of the unit of work.
					
					8. Conclusion
					The concept of persistence context is central to understanding the lifecycle of Hibernate entities. We've clarified the lifecycle by looking into the code examples demonstrating each status.
					
4.JPA Entity Lifecycle Events


							JPA is huge! It covers nearly every aspect of communication between relational databases and the Java application and is deeply integrated into all major frameworks.
				
				If you're using IntelliJ, JPA Buddy is super helpful. The plugin gently guides you through the subtleties of the most popular JPA implementations, visually reminds you of JPA features, generates code that follows best practices, and integrates intelligent inspections to improve your existing persistence code.
				
				More concretely, it provides powerful tooling to generate Spring Data JPA repositories and methods, Flyway Versioned Migrations, Liquibase Differential Changelogs, DDL and SQL statements, DTO objects, and MapStruct interfaces.
				
				Oh, and it actually generates JPA entities from an existing database and gradually update the data model as the database evolves! Yeah.
				
				1. Introduction
								When working with JPA, there are several events that we can be notified of during an entity's lifecycle. In this tutorial, we'll discuss the JPA entity lifecycle events and how we can use annotations to handle the callbacks and execute code when these events occur.
								
								We'll start by annotating methods on the entity itself and then move on to using an entity listener.
								
								2. JPA Entity Lifecycle Events
								JPA specifies seven optional lifecycle events that are called:
								
								before persist is called for a new entity – @PrePersist
								after persist is called for a new entity – @PostPersist
								before an entity is removed – @PreRemove
								after an entity has been deleted – @PostRemove
								before the update operation – @PreUpdate
								after an entity is updated – @PostUpdate
								after an entity has been loaded – @PostLoad
								There are two approaches for using the lifecycle event annotations: annotating methods in the entity and creating an EntityListener with annotated callback methods. We can also use both at the same time. Regardless of where they are, callback methods are required to have a void return type.
								
								So, if we create a new entity and call the save method of our repository, our method annotated with @PrePersist is called, then the record is inserted into the database, and finally, our @PostPersist method is called. If we're using @GeneratedValue to automatically generate our primary keys, we can expect that key to be available in the @PostPersist method.
								
								For the @PostPersist, @PostRemove and @PostUpdate operations, the documentation mentions that these events can happen right after the operation occurs, after a flush, or at the end of a transaction.
								
								We should note that the @PreUpdate callback is only called if the data is actually changed — that is if there's an actual SQL update statement to run. The @PostUpdate callback is called regardless of whether anything actually changed.
								
								If any of our callbacks for persisting or removing an entity throw an exception, the transaction will be rolled back.
								
								3. Annotating the Entity
								Let's start by using the callback annotations directly in our entity. In our example, we're going to leave a log trail when User records are changed, so we're going to add simple logging statements in our callback methods.
								
								Additionally, we want to make sure we assemble the user's full name after they're loaded from the database. We'll do that by annotating a method with @PostLoad.
								
								We'll start by defining our User entity:
								
								@Entity
								public class User {
								    private static Log log = LogFactory.getLog(User.class);
								
								    @Id
								    @GeneratedValue
								    private int id;
								    
								    private String userName;
								    private String firstName;
								    private String lastName;
								    @Transient
								    private String fullName;
								
								    // Standard getters/setters
								}
								Copy
								Next, we need to create a UserRepository interface:
								
								public interface UserRepository extends JpaRepository<User, Integer> {
								    public User findByUserName(String userName);
								}
								Copy
								Now, let's return to our User class and add our callback methods:
								
								@PrePersist
								public void logNewUserAttempt() {
								    log.info("Attempting to add new user with username: " + userName);
								}
								    
								@PostPersist
								public void logNewUserAdded() {
								    log.info("Added user '" + userName + "' with ID: " + id);
								}
								    
								@PreRemove
								public void logUserRemovalAttempt() {
								    log.info("Attempting to delete user: " + userName);
								}
								    
								@PostRemove
								public void logUserRemoval() {
								    log.info("Deleted user: " + userName);
								}
								
								@PreUpdate
								public void logUserUpdateAttempt() {
								    log.info("Attempting to update user: " + userName);
								}
								
								@PostUpdate
								public void logUserUpdate() {
								    log.info("Updated user: " + userName);
								}
								
								@PostLoad
								public void logUserLoad() {
								    fullName = firstName + " " + lastName;
								}
								Copy
								When we run our tests, we'll see a series of logging statements coming from our annotated methods. Additionally, we can reliably expect our user's full name to be populated when we load a user from the database.
								
								4. Annotating an EntityListener
								We're going to expand on our example now and use a separate EntityListener to handle our update callbacks. We might favor this approach over placing the methods in our entity if we have some operation we want to apply to all of our entities.
								
								Let's create our AuditTrailListener to log all the activity on the User table:
								
								public class AuditTrailListener {
								    private static Log log = LogFactory.getLog(AuditTrailListener.class);
								    
								    @PrePersist
								    @PreUpdate
								    @PreRemove
								    private void beforeAnyUpdate(User user) {
								        if (user.getId() == 0) {
								            log.info("[USER AUDIT] About to add a user");
								        } else {
								            log.info("[USER AUDIT] About to update/delete user: " + user.getId());
								        }
								    }
								    
								    @PostPersist
								    @PostUpdate
								    @PostRemove
								    private void afterAnyUpdate(User user) {
								        log.info("[USER AUDIT] add/update/delete complete for user: " + user.getId());
								    }
								    
								    @PostLoad
								    private void afterLoad(User user) {
								        log.info("[USER AUDIT] user loaded from database: " + user.getId());
								    }
								}
								Copy
								As we can see from the example, we can apply multiple annotations to a method.
								
								Now, we need to go back to our User entity and add the @EntityListener annotation to the class:
								
								@EntityListeners(AuditTrailListener.class)
								@Entity
								public class User {
								    //...
								}
								Copy
								And, when we run our tests, we'll get two sets of log messages for each update action and a log message after a user is loaded from the database.
								
								5. Conclusion
								In this article, we've learned what the JPA entity lifecycle callbacks are and when they're called. We looked at the annotations and talked about the rules for using them. We've also experimented with using them in both an entity class and with an EntityListener class.
								
								The example code is available over on GitHub.	
								
								
								https://github.com/eugenp/tutorials/tree/master/persistence-modules/spring-data-jpa-annotations
								
								
4.Default Column Values in JPA


									JPA is huge! It covers nearly every aspect of communication between relational databases and the Java application and is deeply integrated into all major frameworks.
				
				If you're using IntelliJ, JPA Buddy is super helpful. The plugin gently guides you through the subtleties of the most popular JPA implementations, visually reminds you of JPA features, generates code that follows best practices, and integrates intelligent inspections to improve your existing persistence code.
				
				More concretely, it provides powerful tooling to generate Spring Data JPA repositories and methods, Flyway Versioned Migrations, Liquibase Differential Changelogs, DDL and SQL statements, DTO objects, and MapStruct interfaces.
				
				Oh, and it actually generates JPA entities from an existing database and gradually update the data model as the database evolves! Yeah.

		1. Overview
					In this tutorial, we'll look into default column values in JPA.
					
					We'll learn how to set them as a default property in the entity as well as directly in the SQL table definition.
					
					2. While Creating an Entity
					The first way to set a default column value is to set it directly as an entity property value:
					
					@Entity
					public class User {
					    @Id
					    private Long id;
					    private String firstName = "John Snow";
					    private Integer age = 25;
					    private Boolean locked = false;
					}
					Copy
					Now, every time we create an entity using the new operator, it will set the default values we've provided:
					
					@Test
					void saveUser_shouldSaveWithDefaultFieldValues() {
					    User user = new User();
					    user = userRepository.save(user);
					    
					    assertEquals(user.getName(), "John Snow");
					    assertEquals(user.getAge(), 25);
					    assertFalse(user.getLocked());
					}
					Copy
					There is one drawback to this solution.
					
					When we take a look at the SQL table definition, we won't see any default value in it:
					
					create table user
					(
					    id     bigint not null constraint user_pkey primary key,
					    name   varchar(255),
					    age    integer,
					    locked boolean
					);
					Copy
					So, if we override them with null, the entity will be saved without any error:
					
					@Test
					void saveUser_shouldSaveWithNullName() {
					    User user = new User();
					    user.setName(null);
					    user.setAge(null);
					    user.setLocked(null);
					    user = userRepository.save(user);
					
					    assertNull(user.getName());
					    assertNull(user.getAge());
					    assertNull(user.getLocked());
					}
					Copy
					3. In the Schema Definition
					To create a default value directly in the SQL table definition, we can use the @Column annotation and set its columnDefinition parameter:
					
					@Entity
					public class User {
					    @Id
					    Long id;
					
					    @Column(columnDefinition = "varchar(255) default 'John Snow'")
					    private String name;
					
					    @Column(columnDefinition = "integer default 25")
					    private Integer age;
					
					    @Column(columnDefinition = "boolean default false")
					    private Boolean locked;
					}
					Copy
					Using this method, the default value will be present in the SQL table definition:
					
					create table user
					(
					    id     bigint not null constraint user_pkey primary key,
					    name   varchar(255) default 'John Snow',
					    age    integer      default 35,
					    locked boolean      default false
					);
					Copy
					And the entity will be saved properly with the default values:
					
					
					freestar
					@Test
					void saveUser_shouldSaveWithDefaultSqlValues() {
					    User user = new User();
					    user = userRepository.save(user);
					
					    assertEquals(user.getName(), "John Snow");
					    assertEquals(user.getAge(), 25);
					    assertFalse(user.getLocked());
					}
					Copy
					Remember that by using this solution, we won't be able to set a given column to null when saving the entity for the first time. If we don't provide any value, the default one will be set automatically.
					
					4. Conclusion
					In this short article, we learned how to set default column values in JPA.
					
					As always, the full source code is available over on GitHub.
					
					
5.JPA @Basic Annotation


			1. Overview
						In this quick tutorial, we'll explore the JPA @Basic annotation. We'll also discuss the difference between @Basic and @Column JPA annotations.
						
						2. Basic Types
						JPA support various Java data types as persistable fields of an entity, often known as the basic types.
						
						A basic type maps directly to a column in the database. These include Java primitives and their wrapper classes, String, java.math.BigInteger and java.math.BigDecimal, various available date-time classes, enums, and any other type that implements java.io.Serializable.
						
						Hibernate, like any other ORM vendor, maintains a registry of basic types and uses it to resolve a column's specific org.hibernate.type.Type.
						
						3. @Basic Annotation
						We can use the @Basic annotation to mark a basic type property:
						
						@Entity
						public class Course {
						
						    @Basic
						    @Id
						    private int id;
						
						    @Basic
						    private String name;
						    ...
						}
						Copy
						In other words, the @Basic annotation on a field or a property signifies that it's a basic type and Hibernate should use the standard mapping for its persistence.
						
						Note that it's an optional annotation. And so, we can rewrite our Course entity as:
						
						@Entity
						public class Course {
						
						    @Id
						    private int id;
						
						    private String name;
						    ...
						}
						Copy
						When we don't specify the @Basic annotation for a basic type attribute, it is implicitly assumed, and the default values of this annotation apply.
						
						4. Why Use @Basic Annotation?
						The @Basic annotation has two attributes, optional and fetch. Let's take a closer look at each one.
						
						The optional attribute is a boolean parameter that defines whether the marked field or property allows null. It defaults to true. So, if the field is not a primitive type, the underlying column is assumed to be nullable by default.
						
						
						freestar
						The fetch attribute accepts a member of the enumeration Fetch, which specifies whether the marked field or property should be lazily loaded or eagerly fetched. It defaults to FetchType.EAGER, but we can permit lazy loading by setting it to FetchType.LAZY.
						
						Lazy loading will only make sense when we have a large Serializable object mapped as a basic type, as in that case, the field access cost can be significant.
						
						We have a detailed tutorial covering Eager/Lazy loading in Hibernate that takes a deeper dive into the topic.
						
						Now, let's say don't want to allow nulls for our Course‘s name and want to lazily load that property as well. Then, we'll define our Course entity as:
						
						@Entity
						public class Course {
						    
						    @Id
						    private int id;
						    
						    @Basic(optional = false, fetch = FetchType.LAZY)
						    private String name;
						    ...
						}
						Copy
						We should explicitly use the @Basic annotation when willing to deviate from the default values of optional and fetch parameters. We can specify either one or both of these attributes, depending on our needs.
						
						
						freestar
						5. JPA @Basic vs @Column
						Let's look at the differences between @Basic and @Column annotations:
						
						Attributes of the @Basic annotation are applied to JPA entities, whereas the attributes of @Column are applied to the database columns
						@Basic annotation's optional attribute defines whether the entity field can be null or not; on the other hand, @Column annotation's nullable attribute specifies whether the corresponding database column can be null
						We can use @Basic to indicate that a field should be lazily loaded
						The @Column annotation allows us to specify the name of the mapped database column
						6. Conclusion
						In this article, we learned when and how to use JPA's @Basic annotation. We also talked about how it differs from the @Column annotation.
						

6.Mapping Entity Class Names to SQL Table Names with JPA

			1. Introduction
					In this short tutorial, we'll learn how to set SQL table names using JPA.
					
					We'll cover how JPA generates the default names and how to provide custom ones.
					
					2. Default Table Names
					The JPA default table name generation is specific to its implementation.
					
					For instance, in Hibernate the default table name is the name of the class with the first letter capitalized. It's determined through the ImplicitNamingStrategy contract.
					
					But we can change this behavior by implementing a PhysicalNamingStrategy interface.
					
					
					freestar
					3. Using @Table
					The easiest way to set a custom SQL table name is to annotate the entity with @javax.persistence.Table and define its name parameter:
					
					@Entity
					@Table(name = "ARTICLES")
					public class Article {
					    // ...
					}
					Copy
					We can also store the table name in a static final variable:
					
					@Entity
					@Table(name = Article.TABLE_NAME)
					public class Article {
					    public static final String TABLE_NAME= "ARTICLES";
					    // ...
					}
					Copy
					4. Overwriting the Table Name in JPQL Queries
					By default in JPQL queries, we use the entity class name:
					
					select * from Article
					Copy
					But we can change it by defining the name parameter in the @javax.persistence.Entity annotation:
					
					@Entity(name = "MyArticle")
					Copy
					Then we'd change our JPQL query to:
					
					
					freestar
					select * from MyArticle
					Copy
					5. Conclusion
					In this article, we've learned how JPA generates default table names and how to set SQL table names using JPA.
					
								

7.Difference Between @Size, @Length, and @Column  (length=value)


			1. Overview
				In this quick tutorial, we'll take a look at JSR-330‘s @Size annotation, Hibernate‘s @Length annotation, and JPA‘s @Column‘s length attribute.
				
				At first blush, these may seem the same, but they perform different functions.
				
				2. Origins
				Simply put, all of these annotations are meant to communicate the size of a field.
				
				@Size and @Length are similar. We can use either annotation to validate the size of a field. The former is a Java-standard annotation, while the latter is specific to Hibernate.
				
				@Column, though, is a JPA annotation that we use to control DDL statements.
				
				
				freestar
				Now let's go through each of them in detail.
				
				3. @Size
				For validations, we'll use @Size, a bean validation annotation. We'll use the property middleName annotated with @Size to validate its value between the attributes min and max:
				
				public class User {
				
				    // ...
				
				    @Size(min = 3, max = 15)
				    private String middleName;
				
				    // ...
				
				}
				Copy
				Most importantly, @Size makes the bean independent of JPA and its vendors, such as Hibernate. As a result, it's more portable than @Length.
				
				4. @Length
				As we previously mentioned, @Length is the Hibernate-specific version of @Size. We'll enforce the range for lastName using @Length:
				
				@Entity
				public class User {
				
				    // ...
				      
				    @Length(min = 3, max = 15)
				    private String lastName;
				
				    // ...
				
				}
				Copy
				5. @Column(length=value)
				@Column is quite different from the previous two annotations.
				
				We'll use @Column to indicate specific characteristics of the physical database column. We'll use the length attribute of the @Column annotation to specify the string-valued column length:
				
				@Entity
				public class User {
				
				    @Column(length = 3)
				    private String firstName;
				
				    // ...
				
				}
				Copy
				The resulting column will be generated as a VARCHAR(3), and trying to insert a longer string will result in an SQL error.
				
				Note that we'll use @Column only to specify table column properties, as it doesn't provide validations.
				
				Of course, we can use @Column together with @Size to specify database column properties with bean validation:
				
				@Entity
				public class User {
				
				    // ... 
				    
				    @Column(length = 5)
				    @Size(min = 3, max = 5)
				    private String city;
				
				    // ...
				
				}
				Copy
				6. Conclusion
				In this article, we learned about the differences between the @Size annotation, @Length annotation, and @Column‘s length attribute. Then we examined each separately within the areas of their use.
				
							
